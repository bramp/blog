<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on bramp.net</title>
    <link>https://blog.bramp.net/tags/java/</link>
    <description>Recent content in Java on bramp.net</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en_GB</language>
    <lastBuildDate>Thu, 27 Aug 2015 20:39:04 -0700</lastBuildDate>
    <atom:link href="https://blog.bramp.net/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Unsafe Part 3: Benchmarking a java UnsafeArrayList</title>
      <link>https://blog.bramp.net/post/2015/08/27/unsafe-part-3-benchmarking-a-java-unsafearraylist/</link>
      <pubDate>Thu, 27 Aug 2015 20:39:04 -0700</pubDate>
      
      <guid>https://blog.bramp.net/post/2015/08/27/unsafe-part-3-benchmarking-a-java-unsafearraylist/</guid>
      <description>

&lt;p&gt;Previously we introduced a &lt;a href=&#34;https://blog.bramp.net/post/2015/08/26/unsafe-part-2-using-sun.misc.unsafe-to-create-a-contiguous-array-of-objects/&#34;&gt;UnsafeArrayList&lt;/a&gt;, a ArrayList style collection that instead of storing references to the objects, it would copy them into heap allocated memory. This has the unique property of keeping all objects contiguous in memory, and avoids a pointer indirection, at the cost of needing to copy values in and out. I would argue that the copy cost is minor, as it is effectively prefetching the object’s fields into the CPU cache. Saving a memory load when the field is actually used (most likely shortly after it is pulled from the list). However, instead of speculating, this article aims to benchmark the list.&lt;/p&gt;

&lt;h2 id=&#34;methodology:096ff4ca83bc43bcc2f474076ba9052e&#34;&gt;Methodology&lt;/h2&gt;

&lt;p&gt;To test the performance of this new style of list, a series of benchmarks were devised. The new &lt;a href=&#34;http://openjdk.java.net/projects/code-tools/jmh/&#34;&gt;JMH benchmark framework&lt;/a&gt; was used, and final benchmark code is &lt;a href=&#34;https://github.com/bramp/unsafe/tree/master/unsafe-benchmark&#34;&gt;available here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Multiple iterations were run, and unless stated results were calculated with a 99% confidence interval. A couple of warmup iteration were always run and discarded. All tests were run on a Ubuntu Linux 3.19.0-22 desktop, with a 64bit Intel® Core™ i3-2125 CPU @ 3.30GHz, and 16 GiB of 1333 MHz DDR3 RAM. The JVM was OpenJDK (version 1.8.0_45-internal).&lt;/p&gt;

&lt;p&gt;For each benchmark new ArrayLists and UnsafeArrayLists were constructed, and populated with newly created objects. The size of the lists were varied, up to a maximum that could be held in memory without disk swapping. Two artificial workloads were created,&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Reading items from the lists start to finish, and&lt;/li&gt;
&lt;li&gt;Processing the elements in a random order.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The first was reproduced by simply reading the first field of every element of the list in order, and the second by sorting the list based on the object’s fields (with a simple quicksort).&lt;/p&gt;

&lt;p&gt;Three test classes of different sizes were created to be stored within the ArrayLists, one class had two long fields, one had four long fields, and finally one with eight long fields . Named TwoLongs, FourLongs and EightLongs requiring 16, 32, and 64 bytes for the fields respectively. Each iteration these classes were created with random values in the fields.&lt;/p&gt;

&lt;h2 id=&#34;the-results:096ff4ca83bc43bcc2f474076ba9052e&#34;&gt;The Results&lt;/h2&gt;

&lt;table class=&#34;table table-hover table-striped table-condensed&#34;&gt;
    &lt;thead&gt;
        &lt;tr&gt;&lt;th&gt;Benchmark&lt;/th&gt;&lt;th&gt;List&lt;/th&gt;&lt;th&gt;Type&lt;/th&gt;&lt;th&gt;Size&lt;/th&gt;&lt;th class=&#34;text-center&#34;&gt;Mean Time (s)&lt;/th&gt;&lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;&lt;td&gt;Iterate&lt;/td&gt;&lt;td&gt;ArrayList&lt;/td&gt;&lt;td&gt;TwoLongs&lt;/td&gt;&lt;td&gt;80,000,000&lt;/td&gt;&lt;td class=&#34;text-center&#34;&gt;2.266 ± 0.229&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;Iterate&lt;/td&gt;&lt;td&gt;UnsafeArrayList&lt;/td&gt;&lt;td&gt;TwoLongs&lt;/td&gt;&lt;td&gt;80,000,000&lt;/td&gt;&lt;td class=&#34;text-center&#34;&gt;1.79 ± 0.03&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;IterateInPlace&lt;/td&gt;&lt;td&gt;UnsafeArrayList&lt;/td&gt;&lt;td&gt;TwoLongs&lt;/td&gt;&lt;td&gt;80,000,000&lt;/td&gt;&lt;td class=&#34;text-center&#34;&gt;0.442 ± 0.023&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;Iterate&lt;/td&gt;&lt;td&gt;ArrayList&lt;/td&gt;&lt;td&gt;FourLongs&lt;/td&gt;&lt;td&gt;80,000,000&lt;/td&gt;&lt;td class=&#34;text-center&#34;&gt;2.277 ± 0.211&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;Iterate&lt;/td&gt;&lt;td&gt;UnsafeArrayList&lt;/td&gt;&lt;td&gt;FourLongs&lt;/td&gt;&lt;td&gt;80,000,000&lt;/td&gt;&lt;td class=&#34;text-center&#34;&gt;2.126 ± 0.019&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;IterateInPlace&lt;/td&gt;&lt;td&gt;UnsafeArrayList&lt;/td&gt;&lt;td&gt;FourLongs&lt;/td&gt;&lt;td&gt;80,000,000&lt;/td&gt;&lt;td class=&#34;text-center&#34;&gt;0.648 ± 0.019&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;Iterate&lt;/td&gt;&lt;td&gt;ArrayList&lt;/td&gt;&lt;td&gt;EightLongs&lt;/td&gt;&lt;td&gt;80,000,000&lt;/td&gt;&lt;td class=&#34;text-center&#34;&gt;2.792 ± 0.072&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;Iterate&lt;/td&gt;&lt;td&gt;UnsafeArrayList&lt;/td&gt;&lt;td&gt;EightLongs&lt;/td&gt;&lt;td&gt;80,000,000&lt;/td&gt;&lt;td class=&#34;text-center&#34;&gt;2.672 ± 0.322&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;IterateInPlace&lt;/td&gt;&lt;td&gt;UnsafeArrayList&lt;/td&gt;&lt;td&gt;EightLongs&lt;/td&gt;&lt;td&gt;80,000,000&lt;/td&gt;&lt;td class=&#34;text-center&#34;&gt;0.941 ± 0.032&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;Sort&lt;/td&gt;&lt;td&gt;ArrayList&lt;/td&gt;&lt;td&gt;TwoLongs&lt;/td&gt;&lt;td&gt;80,000,000&lt;/td&gt;&lt;td class=&#34;text-center&#34;&gt;70.31 ± 3.939&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;Sort&lt;/td&gt;&lt;td&gt;ArrayList&lt;/td&gt;&lt;td&gt;FourLongs&lt;/td&gt;&lt;td&gt;80,000,000&lt;/td&gt;&lt;td class=&#34;text-center&#34;&gt;79.673 ± 6.119&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;Sort&lt;/td&gt;&lt;td&gt;ArrayList&lt;/td&gt;&lt;td&gt;EightLongs&lt;/td&gt;&lt;td&gt;80,000,000&lt;/td&gt;&lt;td class=&#34;text-center&#34;&gt;97.687 ± 4.86&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;Sort&lt;/td&gt;&lt;td&gt;UnsafeArrayList&lt;/td&gt;&lt;td&gt;TwoLongs&lt;/td&gt;&lt;td&gt;80,000,000&lt;/td&gt;&lt;td class=&#34;text-center&#34;&gt;18.69 ± 3.158&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;Sort&lt;/td&gt;&lt;td&gt;UnsafeArrayList&lt;/td&gt;&lt;td&gt;FourLongs&lt;/td&gt;&lt;td&gt;80,000,000&lt;/td&gt;&lt;td class=&#34;text-center&#34;&gt;24.822 ± 0.79&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;Sort&lt;/td&gt;&lt;td&gt;UnsafeArrayList&lt;/td&gt;&lt;td&gt;EightLongs&lt;/td&gt;&lt;td&gt;80,000,000&lt;/td&gt;&lt;td class=&#34;text-center&#34;&gt;40.697 ± 0.743&lt;/td&gt;&lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;iterate:096ff4ca83bc43bcc2f474076ba9052e&#34;&gt;Iterate&lt;/h3&gt;

&lt;p&gt;Starting with the smallest test object, TwoLongs, to read the first field of all 80 million  elements within an ArrayList took on average 2.266 ± 0.229 seconds. To do the same with the UnsafeArrayList (which doesn’t store objects, and instead copies elements in/out) took on average 1.79 ±0.03 seconds (an 24% improvement).&lt;/p&gt;

&lt;p&gt;Remember in the &lt;a href=&#34;https://blog.bramp.net/post/2015/08/26/unsafe-part-2-using-sun.misc.unsafe-to-create-a-contiguous-array-of-objects/&#34;&gt;previous article&lt;/a&gt;, UnsafeArrayList has two methods for retrieving an element &lt;code&gt;T get(int index)&lt;/code&gt; and a &lt;code&gt;T get(T dest, int index)&lt;/code&gt;. The former creates a new object and copies the fields. The latter copies the fields in place of a given destination object, allowing the reuse of a single temp object, and avoiding creations of new objects, thus is labelled &amp;ldquo;InPlace&amp;rdquo; in the above results.&lt;/p&gt;

&lt;p&gt;It is therefore surprising that the UnsafeArrayList can iterate 24% faster than an ArrayList, when it has the additional overhead of creating an object, and copying fields into it. Compared to an ArrayList which is just reading existing objects.&lt;/p&gt;

&lt;p&gt;Some theory is needed to understand what might be happening here. A modern CISC CPU can execute an instruction in a few clock cycles, let&amp;rsquo;s say ~0.5 nanoseconds, however, reading from RAM takes ~10 nanoseconds. While the CPU is waiting for the response from RAM it is effectively blocked. To compensate the CPU deploys a few tricks, two of which could be helping here. Firstly, the CPU tries to predicting and prefetch the next memory request. Secondly, the CPU will execute instructions out of order, thus not waiting for the memory if a later instruction does not depend on the read.&lt;/p&gt;

&lt;p&gt;In the ArrayList case, the array of reference is stored in contiguous memory. However, the actual objects (that the references point to) could be anywhere in RAM. As the program loops through it is making reads from effectively random locations in memory, that can’t be predicted, and thus stalls the CPU.&lt;/p&gt;

&lt;p&gt;There is no doubt in the UnsafeArrayList the CPU is prefetching the next elements before it is needed. Additionally the cost of creating these short lived objects is most likely very small because they live and die in eden space and are thus simple to create and garbage collect. I also would not be surprised if the CPU or the JIT compiler was able to do &lt;a href=&#34;https://en.wikipedia.org/wiki/Automatic_vectorization&#34;&gt;some kind of vectorising&lt;/a&gt; on the input. That is, concurrently operating on multiple entries at the same time.&lt;/p&gt;

&lt;p&gt;If we then test the &lt;code&gt;T get(T dest, int index)&lt;/code&gt; method (labelled IterateInPlace), it can iterate through the array in an impressive 0.442 ±0.023 seconds. That’s 5 times faster than the ArrayList, and 4 times faster than the &lt;code&gt;T get(int index)&lt;/code&gt;. This is certainly because the objects are not created for each get.&lt;/p&gt;

&lt;p&gt;It was not measured here, but it is possible to confirm what the CPU is doing, by using &lt;a href=&#34;https://en.wikipedia.org/wiki/Hardware_performance_counter&#34;&gt;hardware based performance counters&lt;/a&gt;. These are special registers within the CPU that can be configured to measure cache hit/miss rates, prefetches, instructions per cycle, and many other metrics. These can be invaluable to understand what’s truly going on, as in most cases humans are bad at understanding performance bottlenecks through intuition alone. Tools such as &lt;a href=&#34;http://oprofile.sourceforge.net/&#34;&gt;oprofile&lt;/a&gt;, &lt;a href=&#34;https://perf.wiki.kernel.org/index.php/Main_Page&#34;&gt;perf&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/DTrace&#34;&gt;dtrace&lt;/a&gt; and &lt;a href=&#34;https://sourceware.org/systemtap/&#34;&gt;systemtap&lt;/a&gt; can be used for this.&lt;/p&gt;

&lt;p&gt;To do a quick sanity check, in the ArrayList case it takes an average of 28.325 nanoseconds per element. &lt;a href=&#34;https://en.wikipedia.org/wiki/CAS_latency&#34;&gt;According to wikipedia&lt;/a&gt; it takes between 9.00-18.75 nanoseconds to read from DDR3 memory at 1333 Mhz. Thus this number doesn’t seem unexpected, as the ArrayList has to issue two memory reads, firstly reading sequentially from an array of references, and then reading from the object (which is at an unpredictable address).&lt;/p&gt;

&lt;p&gt;With the UnsafeArrayList in-place test, it takes an average of 5.53 nanoseconds per element. As the fields are stored contiguously in memory, the CPU can efficiency pipeline the requests, amortizing the 9-18 ns memory read cost. Here the speed is most likely limited by either the memory’s bandwidth, or the CPU’s clock cycles.  To read 80 million memory addresses in 0.442 seconds, requires 180 Megatransfers per second, and assuming each object is two longs, or 16 bytes requires ~2.68 GiB/s of throughput. Neither of those values approach the upper limit of what DDR3 is capable of, thus I suspect the time is a combination of this and CPU instructions.&lt;/p&gt;

&lt;h3 id=&#34;sorting:096ff4ca83bc43bcc2f474076ba9052e&#34;&gt;Sorting&lt;/h3&gt;

&lt;p&gt;The second benchmark measured the speed at which the lists could be read and written to somewhat randomly, and in particular sorted. This should cause a less predictable reads from memory.  To sort 80 million elements in the ArrayList took 70.31 ±3.939 seconds, and only 18.69 ±3.158 seconds for the UnsafeArrayList using the in-place get. The relative times is not as impressive as the previous test, but still the UnsafeArrayList is ~3.7 times as quick.  I’m unsure exactly why the UnsafeArrayList would be faster, but I suspect it is related to the fewer memory indirections, and prefetching effect the copying of fields has.&lt;/p&gt;

&lt;p&gt;It’s also worth noting, the increase performance becomes less profound as the size of the stored class increases. For the FourLong the difference between ArrayList and UnsafeArrayList is 3.2x, and for EightLong the difference is 2.4x. This can easily be explained by the increasing cost of copying the fields in and out of the list.&lt;/p&gt;

&lt;h3 id=&#34;other-observations:096ff4ca83bc43bcc2f474076ba9052e&#34;&gt;Other observations&lt;/h3&gt;

&lt;p&gt;Overlooked is the smaller memory requirements for the UnsafeArrayList. A TwoLong instance is 16 bytes of data, plus 16 bytes of JVM object header. Thus an ArrayList of 40 million instances take 2.4 GiB of RAM (32 bytes x 80M), plus an additional 305MiB for an array of 80 million references (assuming &lt;a href=&#34;https://docs.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html#compressedOop&#34;&gt;compressed object pointers&lt;/a&gt; takes 4 bytes each). Totalling 2.68 GiB, whereas the UnsafeArray takes 16 bytes per entry, totaling only 1.2GiB (roughly half the size!).&lt;/p&gt;

&lt;p&gt;Of course if the array is holding larger classes (such as the EightLong), the per object overhead is smaller, in these cases 6.25GiB vs 4.76GiB, roughly 75% the size.&lt;/p&gt;

&lt;p&gt;One last observation of interest is the confidence intervals for the results. A larger error implies more variability in the test runs. For example, if the garbage collector ran during some of the runs, and slowed down the test, it would increase this error. In all the tests using the UnsafeArrayList in-place methods, the confidence interval is smaller, implying more constancy and predictability. This can be important in certain situations, such as real-time systems.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:096ff4ca83bc43bcc2f474076ba9052e&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We benchmarked the &lt;a href=&#34;https://bramp.github.io/unsafe/index.html?net/bramp/unsafe/UnsafeHelper.html&#34;&gt;UnsafeArrayList&lt;/a&gt;, against a normal ArrayList in two artificial workloads. We found that in both the start-to-finish iteration, and in the sorting case, that the UnsafeArrayList was 4-5x faster than its counterpart. This result itself is interesting when designing high performance data structures, however, the use of &lt;a href=&#34;http://www.docjar.com/docs/api/sun/misc/Unsafe.html&#34;&gt;sun.misc.Unsafe&lt;/a&gt; is considered dangerous, and thus the performance comes with many caveats and risks. In fact, it was recently announced that the &lt;a href=&#34;http://blog.dripstat.com/removal-of-sun-misc-unsafe-a-disaster-in-the-making/&#34;&gt;Unsafe class is being deprecated and hidden in java 9&lt;/a&gt;. So instead, this was just an insightful journey into how the CPU can optomise particular workloads, and how Java can be pushed to extreme speeds.&lt;/p&gt;

&lt;p&gt;Your results may vary, and as always you should benchmark your exact workload instead of a hypothetical one, but this was still an interesting experiment.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Unsafe Part 2: Using sun.misc.Unsafe to create a contiguous array of objects</title>
      <link>https://blog.bramp.net/post/2015/08/26/unsafe-part-2-using-sun.misc.unsafe-to-create-a-contiguous-array-of-objects/</link>
      <pubDate>Wed, 26 Aug 2015 17:51:02 -0700</pubDate>
      
      <guid>https://blog.bramp.net/post/2015/08/26/unsafe-part-2-using-sun.misc.unsafe-to-create-a-contiguous-array-of-objects/</guid>
      <description>&lt;p&gt;I recently came across an article from the &lt;a href=&#34;http://mechanical-sympathy.blogspot.com/2012/10/compact-off-heap-structurestuples-in.html&#34;&gt;Mechanical Sympathy blog&lt;/a&gt;, that used the &lt;a href=&#34;https://en.wikipedia.org/wiki/Flyweight_pattern&#34;&gt;flyweight pattern&lt;/a&gt; to build a “compact off-heap” array of objects. They basically allocated an area of memory large enough to store N copies of their object. Then using a single instance of a proxy object, would pack/unpack fields into this memory. For example, let&amp;rsquo;s say we needed to store an array of &lt;a href=&#34;https://docs.oracle.com/javase/7/docs/api/java/awt/Point.html&#34;&gt;Point&lt;/a&gt; objects. We could construct a simple array like so:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;Point&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;points&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Point&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The inefficiency here is that each instance of a Point requires 12-16 bytes of overhead to store metadata about the object (such as class, GC state, etc), and each additional instance adds to the cost of garbage collection. Additionally, the array actually contains references to Point objects stored elsewhere in RAM. These references require a memory indirection when accessing the actual instances.&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&#34;http://mechanical-sympathy.blogspot.com/2012/10/compact-off-heap-structurestuples-in.html&#34;&gt;Mechanical Sympathy&lt;/a&gt; article, they instead packed all the fields of the instances into a contiguous array. For simplification I changed their example, but it was something like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;memory&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;];&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ProxyPoint&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;setIndex&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getX&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;memory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;memory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With this approach there is no overhead for each Point object (as there is only ever one PointProxy, and one array). This also has the interesting property that the fields for all the Points are stored in the same contiguous region of memory.  Which leads to some great cache/CPU benefits. For example, if you read all the points sequentially, adjacent objects share the same CPU cache line, and the CPU can predictably prefetch the next point. This would not be possible with an array of references to Points, as each Point could potentially be stored anywhere in RAM.&lt;/p&gt;

&lt;p&gt;Now with this primer, it would be interesting to have a normal Java &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/util/List.html&#34;&gt;List&lt;/a&gt; that stored fields packed together like this. The above solution only works if you create a proxy object ahead of time knowing what class you would be storing. Using the recently released &lt;a href=&#34;https://bramp.github.io/unsafe/index.html?net/bramp/unsafe/UnsafeHelper.html&#34;&gt;UnsafeHelper class&lt;/a&gt; (&lt;a href=&#34;https://blog.bramp.net/post/2015/08/24/unsafe-part-1-sun.misc.unsafe-helper-classes/&#34;&gt;discussed previously&lt;/a&gt;), I went about to build something that looked like a standard generic ArrayList, that could store any type. But with the benefit of storing all elements in contiguous region of memory.&lt;/p&gt;

&lt;p&gt;The final solution is &lt;a href=&#34;https://bramp.github.io/unsafe/index.html?net/bramp/unsafe/UnsafeArrayList.html&#34;&gt;UnsafeArrayList.java&lt;/a&gt;. This implements the Java List interface, but instead of storing references to objects, it copies the object into a contiguous region of memory. If you are a C++ programmer, you can think of this as a &lt;code&gt;std::vector&amp;lt;Point&amp;gt;&lt;/code&gt; instead of a &lt;code&gt;std::vector&amp;lt;Point*&amp;gt;&lt;/code&gt;. This minor change comes with it’s own pros and cons, outlined later.&lt;/p&gt;

&lt;p&gt;To begin with the list is constructed like so &lt;code&gt;new UnsafeArrayList&amp;lt;Point&amp;gt;(Point.class)&lt;/code&gt;. The &lt;code&gt;Point.class&lt;/code&gt; is passed in so that the list knows what kind of objects it will be storing. This is required due to a limitation in Java’s implementation of generics, that makes it &lt;a href=&#34;http://stackoverflow.com/q/182636/88646&#34;&gt;impossible for a class to know its own generic type&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The constructor begins by calculating the size of an instance, and uses the UnsafeHelper to calculates the offset to the first field within an instance.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;UnsafeArrayList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;capacity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;firstFieldOffset&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UnsafeHelper&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;firstFieldOffset&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;elementSize&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UnsafeHelper&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;sizeOf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;firstFieldOffset&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;unsafe&lt;/span&gt;           &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UnsafeHelper&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getUnsafe&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;An area of memory is then allocated, like so:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;    &lt;span class=&#34;n&#34;&gt;base&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;allocateMemory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;elementSize&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;capacity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This base variable holds the address to the beginning of the memory, and can only be used via the Unsafe class. The memory is large enough to hold &lt;code&gt;capacity&lt;/code&gt; objects of &lt;code&gt;elementSize&lt;/code&gt; bytes.&lt;/p&gt;

&lt;p&gt;Unlike a Java reference, this base address allows &lt;a href=&#34;https://www.cs.umd.edu/class/sum2003/cmsc311/Notes/BitOp/pointer.html&#34;&gt;pointer arithmetic&lt;/a&gt;, and thus to access a particular element we have a simple method to calculate the memory offset:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;offset&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;base&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;elementSize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Then to &lt;a href=&#34;https://bramp.github.io/unsafe/net/bramp/unsafe/UnsafeArrayList.html#set-int-T-&#34;&gt;set&lt;/a&gt; an element within this List, we copy its fields into the allocated memory:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;    &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;element&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;copyMemory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;element&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;firstFieldOffset&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// src, src_offset&lt;/span&gt;
                          &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;offset&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;),&lt;/span&gt;       &lt;span class=&#34;c1&#34;&gt;// dst, dst_offset&lt;/span&gt;
                          &lt;span class=&#34;n&#34;&gt;elementSize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;              &lt;span class=&#34;c1&#34;&gt;// size&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This copies from object &lt;code&gt;element&lt;/code&gt;, starting at offset &lt;code&gt;firstFieldOffset&lt;/code&gt;, into the raw memory address determined by &lt;code&gt;offset(index)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://bramp.github.io/unsafe/net/bramp/unsafe/UnsafeArrayList.html#get-int-&#34;&gt;get&lt;/a&gt; method is a little more problematic, as the List interface expects get to return an instance of the object. Since we aren’t actually storing references to the objects (but copies of their fields), we need to construct an instance and populate it. This is quite costly, and defeats the point of this UnsafeArrayList. Instead an additional &lt;a href=&#34;https://bramp.github.io/unsafe/net/bramp/unsafe/UnsafeArrayList.html#get-T-int-&#34;&gt;get&lt;/a&gt; method is provided, that allows an object to be passed in, which will have its fields replaced.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;copyMemory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;offset&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;),&lt;/span&gt;
                          &lt;span class=&#34;n&#34;&gt;dest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;firstFieldOffset&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;
                          &lt;span class=&#34;n&#34;&gt;elementSize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;For completeness a standard &lt;code&gt;get(int index)&lt;/code&gt; method is provided, which creates a new instance of the object (using unsafe.allocateInstance() instead of &lt;code&gt;new Type&lt;/code&gt;).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;allocateInstance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;You can inspect the rest of the &lt;a href=&#34;https://github.com/bramp/unsafe/blob/master/unsafe-collection/src/main/java/net/bramp/unsafe/UnsafeArrayList.java&#34;&gt;code via GitHub&lt;/a&gt;, but these are the main parts.&lt;/p&gt;

&lt;p&gt;In conclusion, this approach has some pros and cons, but was mostly created for fun.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Pros&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;List&amp;lt;&amp;gt; interfaces that stores objects in contiguous memory&lt;/li&gt;
&lt;li&gt;Better cache locality and CPU performance&lt;/li&gt;
&lt;li&gt;Minimal memory overhead&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Cons&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Uses sun.misc.Unsafe&lt;/li&gt;
&lt;li&gt;Additional CPU cycles needed to copies objects in and out of array&lt;/li&gt;
&lt;li&gt;Copies the class out of the garbage collector’s view, thus if a stored object contains the only references to other objects, the garbage collector will not know it is still used.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the &lt;a href=&#34;https://blog.bramp.net/post/2015/08/27/unsafe-part-3-benchmarking-a-java-unsafearraylist/&#34;&gt;next article&lt;/a&gt;, we&amp;rsquo;ll benchmark this UnsafeArrayList, and investigate the performance impact of the cache locality, and other overheads.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Unsafe Part 1: sun.misc.Unsafe Helper Classes</title>
      <link>https://blog.bramp.net/post/2015/08/24/unsafe-part-1-sun.misc.unsafe-helper-classes/</link>
      <pubDate>Mon, 24 Aug 2015 20:13:58 -0700</pubDate>
      
      <guid>https://blog.bramp.net/post/2015/08/24/unsafe-part-1-sun.misc.unsafe-helper-classes/</guid>
      <description>&lt;p&gt;I recently came across the &lt;a href=&#34;http://www.docjar.com/docs/api/sun/misc/Unsafe.html&#34;&gt;sun.misc.Unsafe class&lt;/a&gt;, a poorly documented, internal API that gives your java program direct access to the JVM’s memory. Of course accessing the JVM’s memory can be considered unsafe, but allows for some exciting opportunities.&lt;/p&gt;

&lt;p&gt;You can use Unsafe to inspect and manipulate the layout of your objects in RAM, allocate memory off the heap, do interesting things with threads, or even &lt;a href=&#34;http://mishadoff.com/blog/java-magic-part-4-sun-dot-misc-dot-unsafe/&#34;&gt;hack in multiple inheritance&lt;/a&gt;. Multiple people have &lt;a href=&#34;https://dzone.com/articles/understanding-sunmiscunsafe&#34;&gt;written about Unsafe&lt;/a&gt; before, and there are some really &lt;a href=&#34;http://mydailyjava.blogspot.com/2013/12/sunmiscunsafe.html&#34;&gt;good articles&lt;/a&gt;, so we won’t cover it here.&lt;/p&gt;

&lt;p&gt;Using unsafe is not too difficult, but I found the need for a few helper methods, thus I created a collection of classes wrapping the Unsafe code, starting with &lt;a href=&#34;https://bramp.github.io/unsafe/index.html?net/bramp/unsafe/UnsafeHelper.html&#34;&gt;UnsafeHelper&lt;/a&gt;. The main methods of interest are &lt;a href=&#34;https://bramp.github.io/unsafe/net/bramp/unsafe/UnsafeHelper.html#getUnsafe--&#34;&gt;getUnsafe()&lt;/a&gt;, &lt;a href=&#34;https://bramp.github.io/unsafe/net/bramp/unsafe/UnsafeHelper.html#sizeOf-java.lang.Object-&#34;&gt;sizeOf()&lt;/a&gt;, &lt;a href=&#34;https://bramp.github.io/unsafe/net/bramp/unsafe/UnsafeHelper.html#firstFieldOffset-java.lang.Class-&#34;&gt;firstFieldOffset()&lt;/a&gt;, &lt;a href=&#34;https://bramp.github.io/unsafe/net/bramp/unsafe/UnsafeHelper.html#toByteArray-java.lang.Object-&#34;&gt;toByteArray()&lt;/a&gt; and &lt;a href=&#34;https://bramp.github.io/unsafe/net/bramp/unsafe/UnsafeHelper.html#hexDump-java.io.PrintStream-java.lang.Object-&#34;&gt;hexDump()&lt;/a&gt;. The &lt;a href=&#34;https://bramp.github.io/unsafe/&#34;&gt;javadoc&lt;/a&gt; is the best place to look for documentation, however I’ll quickly explain their use.&lt;/p&gt;

&lt;p&gt;To get an sun.misc.Unsafe instance, you have to extract it from a private static field within sun.misc.Unsafe class. For ease, the &lt;a href=&#34;https://bramp.github.io/unsafe/net/bramp/unsafe/UnsafeHelper.html#getUnsafe--&#34;&gt;UnsafeHelper.getUnsafe()&lt;/a&gt; method does that.&lt;/p&gt;

&lt;p&gt;When accessing an object, you typically need to know the size of the object (in bytes), and be able to find the offset to individual fields. If you &lt;a href=&#34;http://www.codeinstructions.com/2008/12/java-objects-memory-structure.html&#34;&gt;understand the memory layout&lt;/a&gt; the JVM uses, you’ll know there is a header in front of the Object’s fields. Typically it looks like this, but varies based on CPU architecture, platform, etc:&lt;/p&gt;

&lt;p&gt;&lt;table class=&#34;table table-bordered&#34; style=&#34;margin-bottom: 0px&#34;&gt;
  &lt;tr&gt;
    &lt;th class=&#34;text-center&#34;&gt;0&lt;/th&gt;
    &lt;th class=&#34;text-center&#34;&gt;1&lt;/th&gt;
    &lt;th class=&#34;text-center&#34;&gt;2&lt;/th&gt;
    &lt;th class=&#34;text-center&#34;&gt;3&lt;/th&gt;
    &lt;th class=&#34;text-center&#34;&gt;4&lt;/th&gt;
    &lt;th class=&#34;text-center&#34;&gt;5&lt;/th&gt;
    &lt;th class=&#34;text-center&#34;&gt;6&lt;/th&gt;
    &lt;th class=&#34;text-center&#34;&gt;7&lt;/th&gt;
    &lt;th class=&#34;text-center&#34;&gt;8&lt;/th&gt;
    &lt;th class=&#34;text-center&#34;&gt;9&lt;/th&gt;
    &lt;th class=&#34;text-center&#34;&gt;10&lt;/th&gt;
    &lt;th class=&#34;text-center&#34;&gt;11&lt;/th&gt;
    &lt;th class=&#34;text-center&#34;&gt;12&lt;/th&gt;
    &lt;th class=&#34;text-center&#34;&gt;13&lt;/th&gt;
    &lt;th class=&#34;text-center&#34;&gt;14&lt;/th&gt;
    &lt;th class=&#34;text-center&#34;&gt;15&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&#34;text-center&#34; colspan=&#34;8&#34;&gt;mark word(8)&lt;/td&gt;
    &lt;td class=&#34;text-center&#34; colspan=&#34;4&#34;&gt;klass pointer(4)&lt;/td&gt;
    &lt;td class=&#34;text-center&#34; colspan=&#34;4&#34;&gt;padding&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;div class=&#34;text-right&#34;&gt;More information &lt;a href=&#34;http://www.codeinstructions.com/2008/12/java-objects-memory-structure.html&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;http://stackoverflow.com/a/17348396/88646&#34;&gt;here&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;To hide some of the details, &lt;a href=&#34;https://bramp.github.io/unsafe/net/bramp/unsafe/UnsafeHelper.html#headerSize-java.lang.Object-&#34;&gt;headerSize()&lt;/a&gt; returns the size of the header, and &lt;a href=&#34;https://bramp.github.io/unsafe/net/bramp/unsafe/UnsafeHelper.html#sizeOf-java.lang.Object-&#34;&gt;sizeOf()&lt;/a&gt; return the total size an object including the header in bytes. &lt;a href=&#34;https://bramp.github.io/unsafe/net/bramp/unsafe/UnsafeHelper.html#firstFieldOffset-java.lang.Class-&#34;&gt;firstFieldOffset()&lt;/a&gt; is then useful as it provides the the offset to the first field. Note that &lt;a href=&#34;https://bramp.github.io/unsafe/net/bramp/unsafe/UnsafeHelper.html#headerSize-java.lang.Object-&#34;&gt;headerSize()&lt;/a&gt; and &lt;a href=&#34;https://bramp.github.io/unsafe/net/bramp/unsafe/UnsafeHelper.html#firstFieldOffset-java.lang.Class-&#34;&gt;firstFieldOffset()&lt;/a&gt; do not always return identical results, as padding (not part of the header) may be used to correctly align the first field.&lt;/p&gt;

&lt;p&gt;Next &lt;a href=&#34;https://bramp.github.io/unsafe/net/bramp/unsafe/UnsafeHelper.html#toByteArray-java.lang.Object-&#34;&gt;toByteArray()&lt;/a&gt; will take an object, and copy it (and its header) into a byte array. Useful for easily inspecting, and serialising the object. Finally, &lt;a href=&#34;https://bramp.github.io/unsafe/net/bramp/unsafe/UnsafeHelper.html#hexDump-java.io.PrintStream-java.lang.Object-&#34;&gt;hexDump()&lt;/a&gt; uses the &lt;a href=&#34;https://bramp.github.io/unsafe/net/bramp/unsafe/UnsafeHelper.html#toByteArray-java.lang.Object-&#34;&gt;toByteArray()&lt;/a&gt; to grab an object, and print out a hex representation of the memory, for example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;span class=&#34;cm&#34;&gt;/**&lt;/span&gt;
&lt;span class=&#34;cm&#34;&gt; * hexDump(new Class4()) prints:&lt;/span&gt;
&lt;span class=&#34;cm&#34;&gt; * 0x00000000: 01 00 00 00 00 00 00 00  8A BF 62 DF 67 45 23 01&lt;/span&gt;
&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Class4&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0x01234567&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/**&lt;/span&gt;
&lt;span class=&#34;cm&#34;&gt; * Longs are always 8 byte aligned, so 4 bytes of padding&lt;/span&gt;
&lt;span class=&#34;cm&#34;&gt; * hexDump(new Class8()) prints:&lt;/span&gt;
&lt;span class=&#34;cm&#34;&gt; * 0x00000000: 01 00 00 00 00 00 00 00  9B 81 61 DF 00 00 00 00&lt;/span&gt;
&lt;span class=&#34;cm&#34;&gt; * 0x00000010: EF CD AB 89 67 45 23 01&lt;/span&gt;
&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Class8&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0x0123456789ABCDEF&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the first example, Class4, a simple class with a single int field, takes up 16 bytes of memory, with the first 8 used by the JVM, the 2nd 4 bytes being a class pointer (basically how the object knows what kind of class it is), and the last four actually being the value of the field. The second example shows a similar header, but with bytes 12-16 being used as padding, so that the long field value is 8 byte aligned.&lt;/p&gt;

&lt;p&gt;These helper methods are available in &lt;a href=&#34;https://github.com/bramp/unsafe&#34;&gt;new project on Github&lt;/a&gt;, and downloadable via Maven. Just &lt;a href=&#34;https://oss.sonatype.org/service/local/repositories/releases/content/net/bramp/unsafe/unsafe-helper/1.0/unsafe-helper-1.0.jar&#34;&gt;download the jar file&lt;/a&gt;, or include a maven dependency, and &lt;code&gt;import net.bramp.unsafe.UnsafeHelper&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;span class=&#34;nt&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;net.bramp.unsafe&lt;span class=&#34;nt&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;unsafe-helper&lt;span class=&#34;nt&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0&lt;span class=&#34;nt&#34;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;span class=&#34;nt&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.bramp.net/post/2015/08/26/unsafe-part-2-using-sun.misc.unsafe-to-create-a-contiguous-array-of-objects/&#34;&gt;Next article&lt;/a&gt;, we&amp;rsquo;ll make use of this new UnsafeHelper to build a special List which copies objects, instead of storing references.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Decompile and Recompile Android APK</title>
      <link>https://blog.bramp.net/post/2015/08/01/decompile-and-recompile-android-apk/</link>
      <pubDate>Sat, 01 Aug 2015 12:24:59 -0700</pubDate>
      
      <guid>https://blog.bramp.net/post/2015/08/01/decompile-and-recompile-android-apk/</guid>
      <description>

&lt;p&gt;I had the need to take an existing &lt;a href=&#34;https://en.wikipedia.org/wiki/Android_application_package&#34;&gt;Android APK&lt;/a&gt;, tweak it, and rebuild. This is not too difficult, but I did have to download the tools from a few different sites, and find a full list of instructions. Thus to make this easier, here is a quick recap of what&amp;rsquo;s needed.&lt;/p&gt;

&lt;p&gt;Download the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ibotpeaches.github.io/Apktool/&#34;&gt;apktool&lt;/a&gt; - tool for reverse engineering Android apk files. In this case can extract and rebuild.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html&#34;&gt;keytool&lt;/a&gt; - Java tool for creating keys/certs. Comes with the JDK.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jarsigner.html&#34;&gt;jarsigner&lt;/a&gt; Java tool for signing JAR/APK files. Comes with the JDK.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.android.com/tools/help/zipalign.html&#34;&gt;zipalign&lt;/a&gt; - archive alignment tool, that comes with the Android SDK.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Some extras:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://jd.benow.ca/&#34;&gt;JD-GUI&lt;/a&gt; - Java Decompiler&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/pxb1988/dex2jar&#34;&gt;dex2jar&lt;/a&gt; - Converts Android dex files to class/jar files.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;instructions:096e0b1b76096499632c44bee24eac64&#34;&gt;Instructions:&lt;/h2&gt;

&lt;p&gt;We assume you are on a Linux or Mac, but this will work (with some tweaking) on Windows. Install a recent Java JDK, then the &lt;a href=&#34;https://developer.android.com/sdk/installing/index.html?pkg=tools&#34;&gt;Stand-alone Android SDK&lt;/a&gt;, and finally &lt;a href=&#34;http://ibotpeaches.github.io/Apktool/&#34;&gt;apktool&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Optionally setup some alias:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;span class=&#34;nb&#34;&gt;alias &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;apktool&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;java -jar ~/bin/apktool_2.0.1.jar&amp;#39;&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;alias &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;dex2jar&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;~/bin/dex2jar-2.0/d2j-dex2jar.sh&amp;#39;&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;alias &lt;/span&gt;jd-gui&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;java -jar ~/bin/jd-gui-1.3.0.jar&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;First, unpack the application.apk file. This will create a &amp;ldquo;application&amp;rdquo; directory with assets, resources, compiled code, etc.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;apktool d -r -s application.apk
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now poke around, and edit any of the files in the application directory. If you wish to decompile any java you can do the following:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c&#34;&gt;# Convert the Dex files into standard class files&lt;/span&gt;
d2j-dex2jar.sh application/classes.dex

&lt;span class=&#34;c&#34;&gt;# Now use the JD (Java Decompiler) to inspect the source&lt;/span&gt;
jd-gui classes-dex2jar.jar
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Once you have made your changes, you need to repack the APK. This will create a &lt;code&gt;my_application.apk&lt;/code&gt; file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;apktool b -f -d application
mv application/dist/application.apk my_application.apk
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The APK must be signed before it will run on a device. Create a key if you don&amp;rsquo;t have an existing one. If prompted for a password, enter anything (but remember it).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;keytool -genkey -v -keystore my-release-key.keystore -alias alias_name &lt;span class=&#34;se&#34;&gt;\&lt;/span&gt;
                   -keyalg RSA -keysize &lt;span class=&#34;m&#34;&gt;2048&lt;/span&gt; -validity 10000
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now sign the APK with the key:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c&#34;&gt;# Sign the apk&lt;/span&gt;
jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore my-release-key.keystore my_application.apk alias_name

&lt;span class=&#34;c&#34;&gt;# Verify apk&lt;/span&gt;
jarsigner -verify -verbose -certs my_application.apk
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Finally, the apk must be aligned for optimal loading:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;zipalign -v &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt; my_application.apk my_application-aligned.apk
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Voila, now you have a &lt;code&gt;my_application-aligned.apk&lt;/code&gt; file, which you can side load onto your device.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Grabbing a Certificate with OpenSSL and importing it into Java</title>
      <link>https://blog.bramp.net/post/2014/08/16/grabbing-a-certificate-with-openssl-and-importing-it-into-java/</link>
      <pubDate>Sat, 16 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>https://blog.bramp.net/post/2014/08/16/grabbing-a-certificate-with-openssl-and-importing-it-into-java/</guid>
      <description>&lt;p&gt;Occasionally I have to grab a SSL cert from a server, and turn it into something that Java can use. Here are the quick instructions&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c&#34;&gt;# Store the cert issued by a web server&lt;/span&gt;
openssl s_client -showcerts -connect www.google.com:443 &amp;gt; www.google.com.pem

&lt;span class=&#34;c&#34;&gt;# Convert it from PEM format to DER format&lt;/span&gt;
openssl x509 -in www.google.com.pem -inform PEM -out www.google.com.der -outform DER

&lt;span class=&#34;c&#34;&gt;# Import it into your keystore&lt;/span&gt;
sudo /usr/java6/bin/keytool -import -alias www.google.com -file www.google.com.der -keystore /usr/java6/jre/lib/security/cacerts

&lt;span class=&#34;c&#34;&gt;# The keystore password is by default &amp;quot;changeit&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Groovy / Grails</title>
      <link>https://blog.bramp.net/post/2012/07/04/groovy-/-grails/</link>
      <pubDate>Wed, 04 Jul 2012 00:00:00 +0000</pubDate>
      
      <guid>https://blog.bramp.net/post/2012/07/04/groovy-/-grails/</guid>
      <description>

&lt;p&gt;Over the past couple of weeks I&amp;#8217;ve been playing with Groovy and Grails, and after a somewhat frustrainting week I thought I&amp;#8217;d share my thoughts. &lt;a href=&#34;http://groovy.codehaus.org/&#34; title=&#34;Groovy&#34;&gt;Groovy&lt;/a&gt; is a dynamic language that runs in a standard JVM, and effectively extends the Java langugage. This makes it easy for existing Java programmer to pick it up and ease into it. &lt;a href=&#34;http://grails.org/&#34;&gt;Grails&lt;/a&gt; is the Groovy equilivant of &lt;a href=&#34;http://rubyonrails.org/&#34;&gt;Ruby on Rails&lt;/a&gt;, a rapid web development framework. I had high hopes for both as Groovy adds lots of interesting features to Java, such as &lt;a href=&#34;http://en.wikipedia.org/wiki/Closure_(computer_science)&#34;&gt;Closures&lt;/a&gt;, &lt;a href=&#34;http://en.wikipedia.org/wiki/Type_system&#34;&gt;Dynamic typing&lt;/a&gt;, &lt;a href=&#34;http://en.wikipedia.org/wiki/Mixin&#34;&gt;Mixins&lt;/a&gt;, and lots of clever syntax to reduce code and to speed up the average developer. On top of this Grails can quickly scaffold a &lt;a href=&#34;http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller&#34;&gt;MVC&lt;/a&gt; framework, allowing you to literally build a &lt;a href=&#34;http://en.wikipedia.org/wiki/Create,_read,_update_and_delete&#34;&gt;CRUD&lt;/a&gt; based application in minutes.&lt;/p&gt;

&lt;p&gt;This all sounds great but I think both of these technologies are still young and there are a lot of things to work out. I was consistently hitting bugs in Grails, and I found the support for Groovy to be lacking in my IDE of choice Ecplise, forcing me to move to IntelliJ which did a lot better job.&lt;/p&gt;

&lt;h1 id=&#34;groovy:3c667ab411b201f728af02293c4d56f8&#34;&gt;Groovy&lt;/h1&gt;

&lt;h2 id=&#34;dynamic-typing:3c667ab411b201f728af02293c4d56f8&#34;&gt;Dynamic typing&lt;/h2&gt;

&lt;p&gt;The dynamic variable typing allows you to create a variable and not declare what type it is. Then as you use the variable you can very easily convert it between types. To be honest, and maybe I miss the point, but I&amp;#8217;ve never been fond of dynamic typing in other languages. I tend to create a variable and ensure I keep it a particular type. I do this because dynamic typing can introduce all sorts of errors, and you have to truely understand the rules. For example, if I try and convert a String to a boolean (as I might do in a condition), what type of Strings evaluate to true and false? In Groovy a empty string is false, but a string with a single whitespace char would be true.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;someString&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;someString&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// a useful example of String-&amp;gt;boolean conversion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Groovy also adds &lt;a href=&#34;http://en.wikipedia.org/wiki/Duck_typing&#34;&gt;duck typing&lt;/a&gt;. If a variable walks like a duck, quacks like a duck then it must be a duck. This is effectively a way to avoid having to implement a interface by checking at runtime if the class has a particular method. This is only useful because at runtime Groovy allows methods to be add (and removed) from classes. This thus allow from some interesting programming, however I find it very error prone. As a method could be added to a class at runtime there is no compile-time checking.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;SomeObject&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;

&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;SomeObject&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SomeObject&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;someMethod&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// This code is valid at compile time, but only at runtime with an MissingMethod exception be thrown.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Because of the dynamic nature a lot of the silly typo errors that should be caught at compile time, will only now be found at run time. Mistyping a method name wasn&amp;#8217;t caught until that line of code was reached. Also, due to dynamic typing, errors such as calling a method with the wrong argument types were not caught. I found this very frustrating as it slowed down my development.  This also makes me dread what will happen if this code is pushed into production without a very rigorous 100% line test coverage.&lt;/p&gt;

&lt;p&gt;It looks like Groovy 2.0 is trying to resolve this concern with &lt;a href=&#34;http://docs.codehaus.org/display/GroovyJSR/GEP+8+-+Static+type+checking&#34;&gt;GEP 8&lt;/a&gt;, a new type of annotation that will force Groovy to statically check your class/method at compile time.&lt;/p&gt;

&lt;h1 id=&#34;grails:3c667ab411b201f728af02293c4d56f8&#34;&gt;Grails&lt;/h1&gt;

&lt;h2 id=&#34;gorm:3c667ab411b201f728af02293c4d56f8&#34;&gt;GORM&lt;/h2&gt;

&lt;p&gt;The GORM is Grails&amp;#8217;s &lt;a href=&#34;http://en.wikipedia.org/wiki/Object-relational_mapping&#34;&gt;ORM&lt;/a&gt;, which sits on top of &lt;a href=&#34;http://www.hibernate.org/&#34;&gt;Hibernate&lt;/a&gt;. It takes advantage of Groovy&amp;#8217;s &lt;a href=&#34;http://groovy.codehaus.org/Collections&#34;&gt;collection syntax&lt;/a&gt; to make configuring a model easy. However, I think due to the young nature of Grails I found multiple problems with GORM. I started by using the super convenient &lt;a href=&#34;http://www.h2database.com/&#34;&gt;H2&lt;/a&gt; data source for testing. Then as I progressed I moved to MySQL. However, the code that worked perfectly with with H2 stopped working in MySQL. There were little things, like reserved keywords being different, which tripped up MySQL. Looking at the generated SQL the MySQL queries weren&amp;#8217;t being escaped, which would have solved this issue. Secondly, and a bigger issue, but I was using hierarchical data models. That is, I had a generic abstract Base model, and multiple specific models that extended from the base. This worked well in H2 and avoided a lot of duplication of code, but with the MySQL data source it was handled incorrectly, causing me to spend hours investigating and modifying the code.&lt;/p&gt;

&lt;p&gt;I also tried the &lt;a href=&#34;http://grails.org/plugin/mongodb&#34;&gt;MongoDB plugin&lt;/a&gt;, as the document store concept works great for my heirachy concept. However it wasn&amp;#8217;t a direct drop in replacement for H2/MySQL, and I even found some bugs, which I &lt;a href=&#34;http://jira.grails.org/browse/GPMONGODB-210&#34;&gt;reported&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;scaffolding:3c667ab411b201f728af02293c4d56f8&#34;&gt;Scaffolding&lt;/h2&gt;

&lt;p&gt;This was one of the coolest features, but also one of the biggest let downs. Scaffolding generates all the code you quickly need for a simple CRUD application. There are two modes, dynamic and static. A dynaimic one literally allows you to create a controller in just a few lines, with all the code for create/read/update/delete hidden behind the scenes. Static scaffolding is very similar in features, but placed all the code in the groovy file ready for you to edit.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;SomeController&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;scaffold&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Author&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// This is all you need for a CRUD controller that maps to the Author model&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The problem I found here is that it dynamic scaffolding served little purpose than showing off how little you could write. To actually customise it you would have to use static scaffolding. Even then, the static scaffolding didn&amp;#8217;t seem particular neat and simple (as compared to other rapid dev frameworks I&amp;#8217;ve used), and you eventually had to throw 90% of that generated code away and write it all yourself.&lt;/p&gt;

&lt;h2 id=&#34;closures:3c667ab411b201f728af02293c4d56f8&#34;&gt;Closures&lt;/h2&gt;

&lt;p&gt;The concept of closures and anonymous functions is a very cool one, which in fact I have quite liked using in Python and JavaScript. The implementation here also seemed quite good, except for some minor pet pevs I had. The real issue I had with closures is how it polluted the call stack. Some of my call stacks were now chains of methods like:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;at _GrailsCompile_groovy$_run_closure2.doCall(_GrailsCompile_groovy:46)
at com.springsource.loaded.ri.ReflectiveInterceptor.jlrMethodInvoke(ReflectiveInterceptor.java:1231)
at org.codehaus.gant.GantMetaClass.invokeMethod(GantMetaClass.java:133)
at com.springsource.loaded.ri.ReflectiveInterceptor.jlrMethodInvoke(ReflectiveInterceptor.java:1231)
at org.codehaus.gant.GantMetaClass.invokeMethod(GantMetaClass.java:133)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This is no doubt a limitation of being built onto of the JVM that couldn&amp;#8217;t provide more helpful output.&lt;/p&gt;

&lt;h2 id=&#34;run-app:3c667ab411b201f728af02293c4d56f8&#34;&gt;Run-app&lt;/h2&gt;

&lt;p&gt;Grails comes with a CLI tool that does a lot of the code generation for you. One of the useful commands is &lt;code&gt;grails run-app&lt;/code&gt;, this will start up an embedded webserver which runs your application, and better yet, allows you to make code changes without recompiling/redeploying. This truly makes it quicker to develop and test your Java/Groovy, and allows those minor tweaks to your Controllers, etc without a wait. However, yet again I was let down by this feature. Lots of simple changes would cause the run-app to stop serving my pages with odd exception. The solution was to stop the webserver and start it again, which defeats the purpose. Even worse, I sometimes had to &lt;code&gt;grails clean&lt;/code&gt; as it did not always pick up my code changes.&lt;/p&gt;

&lt;h1 id=&#34;conclusion:3c667ab411b201f728af02293c4d56f8&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;I liked everything that Groovy and Grails was trying to do, but I think their implementation isn&amp;#8217;t good enough yet, and there are too many gotchas for me to considering using this in a production environment. I no doubt will follow it&amp;#8217;s progress and play with it every so often.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>