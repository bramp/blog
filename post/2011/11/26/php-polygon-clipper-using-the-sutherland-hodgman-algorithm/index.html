<!DOCTYPE html><html lang=en><head><meta charset=utf-8><title>PHP Polygon Clipper using the Sutherland-Hodgman algorithm</title><meta name=description content=""><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo"/><link rel=canonical href="http://blog.bramp.net/post/2011/11/26/php-polygon-clipper-using-the-sutherland-hodgman-algorithm/"/><link href="" rel=alternate type=application/rss+xml title="PHP Polygon Clipper using the Sutherland-Hodgman algorithm"/><link href=/css/bootstrap.min.css rel=stylesheet><link href=/css/bramp.css rel=stylesheet><link href=/css/pygments-friendly.css rel=stylesheet><link href=//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css rel=stylesheet><meta name=twitter:card content="summary"/><meta name=twitter:site content="@TheBramp"/><meta name=twitter:title content="PHP Polygon Clipper using the Sutherland-Hodgman algorithm"/><meta name=twitter:description content=""/><script></script><body><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-136478-5', 'auto');
    ga('send', 'pageview');</script><div id=wrapper><div class="navbar navbar-default" role=navigation><div class=container><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=.navbar-collapse><span class=sr-only>Toggle navigation</span> <span class=icon-bar></span> <span class=icon-bar></span> <span class=icon-bar></span></button><div class=navbar-brand><a href="/"><img src="//secure.gravatar.com/avatar/69259b422a1a9266e17977f8ec9d939e?s=64" class=profile-image alt=Home></a><div><a href="/about-me/">Andrew Brampton</a><div id=social-wrapper><a href=https://twitter.com/TheBramp><i class="fa fa-twitter-square"></i></a> <a href=https://www.linkedin.com/in/bramp><i class="fa fa-linkedin-square"></i></a> <a href=https://www.facebook.com/bramp><i class="fa fa-facebook-square"></i></a> <a href=https://github.com/bramp><i class="fa fa-github-square"></i></a> <a href=/index.xml><i class="fa fa-rss-square"></i></a></div></div></div></div><div class="navbar-collapse collapse"><ul class="nav navbar-nav"><li><a href="/">Articles</a></li><li><a href="/about-me/">About Me</a></li><li><a href="/android-app/">Android Apps</a></li><li><a href="/opensource-project/">Open Source</a></li><li><a href="/publication/">Publications</a></li></ul></div></div></div><div class="container main"><div id=article><h1>PHP Polygon Clipper using the Sutherland-Hodgman algorithm</h1><p class=meta><i class="fa fa-calendar-o"></i> 2011-11-26 | <a href=http://blog.bramp.net/tags/algorithm>algorithm</a> | <a href=http://blog.bramp.net/tags/clip>clip</a> | <a href=http://blog.bramp.net/tags/php>PHP</a></p><div class=post><p>I wrote a PHP implementation of the polygon clipping algorithm by Sutherland-Hodgman. Available below, or from <a href=https://gist.github.com/bramp/1396058#file-clip-class-php>github</a>.</p><div class=highlight><pre><span class=o>&lt;?</span><span class=nx>php</span>
<span class=sd>/**</span>
<span class=sd> * Polygon Clipping</span>
<span class=sd> * @author Andrew Brampton me &lt;at&gt; bramp &lt;dot&gt; net</span>
<span class=sd> * @url http://bramp.net/blog/2011/11/php-polygon-clipper-using-the-sutherland-hodgman-algorithm/</span>
<span class=sd> *</span>
<span class=sd> * Based on the Sutherland-Hodgman algorithm (1974).</span>
<span class=sd> * http://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm</span>
<span class=sd> *</span>
<span class=sd> * This approache assumes four clip edges (the bounding box).</span>
<span class=sd> * The original algorithm iterated though each clip edge, and then each point. Instead</span>
<span class=sd> * we iterate each point, and then clip edge. This reduces the memory usage. TODO Measure if that is useful!</span>
<span class=sd> *</span>
<span class=sd> * Usage:</span>
<span class=sd> *   require(&#39;clip.class.php&#39;);</span>
<span class=sd> * </span>
<span class=sd> *   // Create a cliper with bounds defined by the points (x1, y1)-(x2,y2);</span>
<span class=sd> *   $clip = new SutherlandHodgman($x1, $y1, $x2, $y2);</span>
<span class=sd> * </span>
<span class=sd> *   // Create array of 2 tuple coordinates</span>
<span class=sd> *   $points = { {x1, y1}, {x2, y2} ... {xN, yN} }&#39;</span>
<span class=sd> *</span>
<span class=sd> *   // Clip! The resulting array will only have points within the bounds</span>
<span class=sd> *   $points = $clip-&gt;clip($points);</span>
<span class=sd> *</span>
<span class=sd> */</span>

<span class=k>abstract</span> <span class=k>class</span> <span class=nc>Edge</span> <span class=p>{</span>

	<span class=k>var</span> <span class=nv>$bound</span><span class=p>;</span>

	<span class=k>function</span> <span class=nf>__construct</span><span class=p>(</span><span class=nv>$bound</span><span class=p>)</span> <span class=p>{</span>
		<span class=nv>$this</span><span class=o>-&gt;</span><span class=na>bound</span> <span class=o>=</span> <span class=nv>$bound</span><span class=p>;</span>
	<span class=p>}</span>

	<span class=sd>/**</span>
<span class=sd>	 * Is point $p inside the bounds. Techinically is it on the inside</span>
<span class=sd>	 * of the infinite edge defined by $bound</span>
<span class=sd>	 *</span>
<span class=sd>	 * @param point $p</span>
<span class=sd>	 */</span>
	<span class=k>abstract</span> <span class=k>function</span> <span class=nf>inside</span><span class=p>(</span><span class=nv>$p</span><span class=p>);</span>

	<span class=sd>/**</span>
<span class=sd>	 * Finds the intersection with the bounds, on the line p1-p2</span>
<span class=sd>	 *</span>
<span class=sd>	 * @param point $p1 The point inside the bounds</span>
<span class=sd>	 * @param point $p2 The point outside the bounds</span>
<span class=sd>	 */</span>
	<span class=k>abstract</span> <span class=k>function</span> <span class=nf>intersect</span><span class=p>(</span><span class=nv>$p1</span><span class=p>,</span> <span class=nv>$p2</span><span class=p>);</span>
<span class=p>}</span>

<span class=k>abstract</span> <span class=k>class</span> <span class=nc>HorzEdge</span> <span class=k>extends</span> <span class=nx>Edge</span> <span class=p>{</span>

	<span class=sd>/**</span>
<span class=sd>	 * Returns the point at which the line $p1-$p2 hits the horz boundary</span>
<span class=sd>	 *</span>
<span class=sd>	 * @param point $p1</span>
<span class=sd>	 * @param point $p2</span>
<span class=sd>	 *</span>
<span class=sd>	 * @return point</span>
<span class=sd>	 */</span>
	<span class=k>function</span> <span class=nf>intersect</span><span class=p>(</span><span class=nv>$p1</span><span class=p>,</span> <span class=nv>$p2</span><span class=p>)</span> <span class=p>{</span>
		<span class=nv>$dY</span> <span class=o>=</span> <span class=nv>$p2</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=nv>$p1</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>

		<span class=k>if</span> <span class=p>(</span><span class=nv>$dY</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
			<span class=k>return</span> <span class=k>array</span><span class=p>(</span><span class=nv>$p1</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=nv>$this</span><span class=o>-&gt;</span><span class=na>bound</span><span class=p>);</span>

		<span class=nv>$dX</span> <span class=o>=</span> <span class=nv>$p2</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>-</span> <span class=nv>$p1</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
		<span class=nv>$dY2</span> <span class=o>=</span> <span class=p>(</span><span class=nv>$this</span><span class=o>-&gt;</span><span class=na>bound</span> <span class=o>-</span> <span class=nv>$p1</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>

		<span class=k>return</span> <span class=k>array</span><span class=p>((</span><span class=nv>$dY2</span> <span class=o>/</span> <span class=nv>$dY</span><span class=p>)</span> <span class=o>*</span> <span class=nv>$dX</span> <span class=o>+</span> <span class=nv>$p1</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=nv>$this</span><span class=o>-&gt;</span><span class=na>bound</span><span class=p>);</span>
	<span class=p>}</span>
<span class=p>}</span>

<span class=k>abstract</span> <span class=k>class</span> <span class=nc>VertEdge</span> <span class=k>extends</span> <span class=nx>Edge</span> <span class=p>{</span>

	<span class=sd>/**</span>
<span class=sd>	* Returns the point at which the line $p1-$p2 hits the vertical boundary</span>
<span class=sd>	*</span>
<span class=sd>	* @param point $p1</span>
<span class=sd>	* @param point $p2</span>
<span class=sd>	*</span>
<span class=sd>	* @return point</span>
<span class=sd>	*/</span>
	<span class=k>function</span> <span class=nf>intersect</span><span class=p>(</span><span class=nv>$p1</span><span class=p>,</span> <span class=nv>$p2</span><span class=p>)</span> <span class=p>{</span>
		<span class=nv>$dX</span> <span class=o>=</span> <span class=nv>$p2</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>-</span> <span class=nv>$p1</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>

		<span class=k>if</span> <span class=p>(</span><span class=nv>$dX</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
			<span class=k>return</span> <span class=k>array</span><span class=p>(</span><span class=nv>$this</span><span class=o>-&gt;</span><span class=na>bound</span><span class=p>,</span> <span class=nv>$p1</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>

		<span class=nv>$dY</span> <span class=o>=</span> <span class=nv>$p2</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=nv>$p1</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
		<span class=nv>$dX2</span> <span class=o>=</span> <span class=p>(</span><span class=nv>$this</span><span class=o>-&gt;</span><span class=na>bound</span> <span class=o>-</span> <span class=nv>$p1</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>

		<span class=k>return</span> <span class=k>array</span><span class=p>(</span><span class=nv>$this</span><span class=o>-&gt;</span><span class=na>bound</span><span class=p>,</span> <span class=p>(</span><span class=nv>$dX2</span> <span class=o>/</span> <span class=nv>$dX</span><span class=p>)</span> <span class=o>*</span> <span class=nv>$dY</span> <span class=o>+</span> <span class=nv>$p1</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
	<span class=p>}</span>
<span class=p>}</span>

<span class=k>function</span> <span class=nf>intersect</span><span class=p>(</span><span class=nv>$p1</span><span class=p>,</span> <span class=nv>$p2</span><span class=p>)</span> <span class=p>{</span>
	<span class=nv>$dX</span> <span class=o>=</span> <span class=nv>$p2</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>-</span> <span class=nv>$p1</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
	<span class=nv>$dY</span> <span class=o>=</span> <span class=nv>$p2</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=nv>$p1</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
<span class=p>}</span>

<span class=k>class</span> <span class=nc>RightEdge</span> <span class=k>extends</span> <span class=nx>VertEdge</span> <span class=p>{</span>
	<span class=k>function</span> <span class=nf>inside</span><span class=p>(</span><span class=nv>$p</span><span class=p>)</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nv>$p</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>&lt;</span> <span class=nv>$this</span><span class=o>-&gt;</span><span class=na>bound</span><span class=p>;</span> <span class=c1>//X</span>
	<span class=p>}</span>
<span class=p>}</span>

<span class=k>class</span> <span class=nc>LeftEdge</span> <span class=k>extends</span> <span class=nx>VertEdge</span> <span class=p>{</span>

	<span class=k>function</span> <span class=nf>inside</span><span class=p>(</span><span class=nv>$p</span><span class=p>)</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nv>$p</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>&gt;=</span> <span class=nv>$this</span><span class=o>-&gt;</span><span class=na>bound</span><span class=p>;</span> <span class=c1>//X</span>
	<span class=p>}</span>
<span class=p>}</span>

<span class=k>class</span> <span class=nc>TopEdge</span> <span class=k>extends</span> <span class=nx>HorzEdge</span> <span class=p>{</span>
	<span class=k>function</span> <span class=nf>inside</span><span class=p>(</span><span class=nv>$p</span><span class=p>)</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nv>$p</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>&gt;=</span> <span class=nv>$this</span><span class=o>-&gt;</span><span class=na>bound</span><span class=p>;</span> <span class=c1>//Y</span>
	<span class=p>}</span>
<span class=p>}</span>

<span class=k>class</span> <span class=nc>BottomEdge</span> <span class=k>extends</span> <span class=nx>HorzEdge</span> <span class=p>{</span>
	<span class=k>function</span> <span class=nf>inside</span><span class=p>(</span><span class=nv>$p</span><span class=p>)</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nv>$p</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>&lt;</span> <span class=nv>$this</span><span class=o>-&gt;</span><span class=na>bound</span><span class=p>;</span> <span class=c1>//Y</span>
	<span class=p>}</span>
<span class=p>}</span>

<span class=k>function</span> <span class=nf>check_point</span><span class=p>(</span><span class=nv>$p</span><span class=p>,</span> <span class=nv>$msg</span><span class=p>)</span> <span class=p>{</span>
	<span class=k>if</span> <span class=p>(</span><span class=nv>$p</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>&lt;</span> <span class=o>-</span><span class=mi>180</span> <span class=o>||</span> <span class=nv>$p</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>&gt;</span> <span class=mi>180</span> <span class=o>||</span> <span class=nv>$p</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>&lt;</span> <span class=o>-</span><span class=mi>90</span> <span class=o>||</span> <span class=nv>$p</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>&gt;</span> <span class=mi>90</span><span class=p>)</span> <span class=p>{</span>
		<span class=nb>var_dump</span><span class=p>(</span><span class=nv>$p</span><span class=p>);</span>
		<span class=nb>var_dump</span><span class=p>(</span><span class=nb>debug_backtrace</span><span class=p>());</span>
		<span class=k>die</span><span class=p>(</span><span class=s2>&quot;Something went wrong! </span><span class=si>$msg</span><span class=s2>&quot;</span><span class=p>);</span>
	<span class=p>}</span>
<span class=p>}</span>

<span class=k>class</span> <span class=nc>SutherlandHodgman</span> <span class=p>{</span>

	<span class=k>var</span> <span class=nv>$edges</span><span class=p>;</span>

	<span class=sd>/**</span>
<span class=sd>	 * Construct with the bounds of the clipped area</span>
<span class=sd>	 *</span>
<span class=sd>	 * @param unknown_type $x1</span>
<span class=sd>	 * @param unknown_type $y1</span>
<span class=sd>	 * @param unknown_type $x2</span>
<span class=sd>	 * @param unknown_type $y2</span>
<span class=sd>	 */</span>
	<span class=k>function</span> <span class=nf>__construct</span><span class=p>(</span><span class=nv>$x1</span><span class=p>,</span> <span class=nv>$y1</span><span class=p>,</span> <span class=nv>$x2</span><span class=p>,</span> <span class=nv>$y2</span><span class=p>)</span> <span class=p>{</span>
		<span class=nb>assert</span><span class=p>(</span><span class=nv>$x1</span> <span class=o>&lt;</span> <span class=nv>$x2</span><span class=p>);</span>
		<span class=nb>assert</span><span class=p>(</span><span class=nv>$y1</span> <span class=o>&lt;</span> <span class=nv>$y2</span><span class=p>);</span>

		<span class=nv>$this</span><span class=o>-&gt;</span><span class=na>edges</span> <span class=o>=</span> <span class=k>array</span><span class=p>(</span>
			<span class=k>new</span> <span class=nx>RightEdge</span><span class=p>(</span><span class=nv>$x2</span><span class=p>),</span>
			<span class=k>new</span> <span class=nx>TopEdge</span><span class=p>(</span><span class=nv>$y1</span><span class=p>),</span>
			<span class=k>new</span> <span class=nx>LeftEdge</span><span class=p>(</span><span class=nv>$x1</span><span class=p>),</span>
			<span class=k>new</span> <span class=nx>BottomEdge</span><span class=p>(</span><span class=nv>$y2</span><span class=p>)</span>
		<span class=p>);</span>
	<span class=p>}</span>

	<span class=sd>/**</span>
<span class=sd>	 * Clip the array of (x,y) coords to the bounds</span>
<span class=sd>	 * specified in the constructor</span>
<span class=sd>	 *</span>
<span class=sd>	 * @param array $points</span>
<span class=sd>	 */</span>
	<span class=k>function</span> <span class=nf>clip</span><span class=p>(</span><span class=nv>$points</span><span class=p>)</span> <span class=p>{</span>

		<span class=k>if</span> <span class=p>(</span><span class=nb>count</span><span class=p>(</span><span class=nv>$points</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>3</span><span class=p>)</span>
			<span class=k>throw</span> <span class=s2>&quot;Clip requires a polygon of three points or more&quot;</span><span class=p>;</span>

		<span class=k>foreach</span> <span class=p>(</span><span class=nv>$this</span><span class=o>-&gt;</span><span class=na>edges</span> <span class=k>as</span> <span class=nv>$edge</span><span class=p>)</span> <span class=p>{</span>
			<span class=nv>$output</span> <span class=o>=</span> <span class=k>array</span><span class=p>();</span>

			<span class=k>if</span> <span class=p>(</span><span class=k>empty</span><span class=p>(</span><span class=nv>$points</span><span class=p>))</span>
				<span class=k>return</span> <span class=nv>$points</span><span class=p>;</span>

			<span class=nv>$previous</span> <span class=o>=</span> <span class=nv>$points</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
			<span class=nv>$previousInside</span> <span class=o>=</span> <span class=nv>$edge</span><span class=o>-&gt;</span><span class=na>inside</span><span class=p>(</span><span class=nv>$previous</span><span class=p>);</span>

			<span class=c1>// Add the first onto the end so it eventually gets processed</span>
			<span class=nv>$points_count</span> <span class=o>=</span> <span class=nb>count</span><span class=p>(</span><span class=nv>$points</span><span class=p>);</span>
			<span class=k>if</span> <span class=p>(</span><span class=nv>$points</span><span class=p>[</span><span class=nv>$points_count</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>!==</span> <span class=nv>$points</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=p>{</span>
				<span class=nv>$points</span><span class=p>[]</span> <span class=o>=</span> <span class=nv>$points</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
				<span class=nv>$points_count</span><span class=o>++</span><span class=p>;</span>
			<span class=p>}</span>

			<span class=k>for</span> <span class=p>(</span><span class=nv>$i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=nv>$i</span> <span class=o>&lt;</span> <span class=nv>$points_count</span><span class=p>;</span> <span class=nv>$i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
				<span class=nv>$point</span> <span class=o>=</span> <span class=nv>$points</span><span class=p>[</span><span class=nv>$i</span><span class=p>];</span>

				<span class=nb>assert</span><span class=p>(</span><span class=nb>is_array</span><span class=p>(</span><span class=nv>$point</span><span class=p>));</span>
				<span class=nb>assert</span><span class=p>(</span><span class=nb>count</span><span class=p>(</span><span class=nv>$point</span><span class=p>)</span> <span class=o>==</span> <span class=mi>2</span><span class=p>);</span>

				<span class=nv>$inside</span> <span class=o>=</span> <span class=nv>$edge</span><span class=o>-&gt;</span><span class=na>inside</span><span class=p>(</span><span class=nv>$point</span><span class=p>);</span>

				<span class=k>if</span> <span class=p>(</span><span class=nv>$inside</span><span class=p>)</span> <span class=p>{</span>
					<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nv>$previousInside</span><span class=p>)</span> <span class=p>{</span>
						<span class=nb>assert</span><span class=p>(</span><span class=o>!</span><span class=nv>$edge</span><span class=o>-&gt;</span><span class=na>inside</span><span class=p>(</span><span class=nv>$previous</span><span class=p>));</span>
						<span class=nv>$output</span><span class=p>[]</span> <span class=o>=</span> <span class=nv>$edge</span><span class=o>-&gt;</span><span class=na>intersect</span><span class=p>(</span><span class=nv>$point</span><span class=p>,</span> <span class=nv>$previous</span><span class=p>);</span>
					<span class=p>}</span>

					<span class=nv>$output</span><span class=p>[]</span> <span class=o>=</span> <span class=nv>$point</span><span class=p>;</span>

				<span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nv>$previousInside</span><span class=p>)</span> <span class=p>{</span>
					<span class=nb>assert</span><span class=p>(</span><span class=nv>$edge</span><span class=o>-&gt;</span><span class=na>inside</span><span class=p>(</span><span class=nv>$previous</span><span class=p>));</span>
					<span class=nv>$output</span><span class=p>[]</span> <span class=o>=</span> <span class=nv>$edge</span><span class=o>-&gt;</span><span class=na>intersect</span><span class=p>(</span><span class=nv>$previous</span><span class=p>,</span> <span class=nv>$point</span><span class=p>);</span>
				<span class=p>}</span>

				<span class=nv>$previous</span> <span class=o>=</span> <span class=nv>$point</span><span class=p>;</span>
				<span class=nv>$previousInside</span> <span class=o>=</span> <span class=nv>$inside</span><span class=p>;</span>
			<span class=p>}</span>

			<span class=nv>$points</span> <span class=o>=</span> <span class=nv>$output</span><span class=p>;</span>
		<span class=p>}</span>

		<span class=k>return</span> <span class=nv>$output</span><span class=p>;</span>
	<span class=p>}</span>
<span class=p>}</span>
</pre></div></div></div><div class=addthis_sharing_toolbox></div><ul class=pager>&nbsp;<li class=previous><a href="/post/2011/11/22/building-phps-debian-package-nightmare/">&larr; Building PHPâ€™s Debian package nightmare</a></li>&nbsp;<li class=next><a href="/post/2012/01/14/avoid-bloat-freezer-free/">Avoid Bloat Freezer Free &rarr;</a></li></ul><div id=disqus_thread></div><script type=text/javascript>(function() {
    
    
    if (window.location.hostname == "localhost" || window.location.port == 1313) 
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//bramp.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a href=http://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><br/><footer><p class="text-muted credit">&copy; 2015. All rights reserved.</p></footer></div></div><script src=/js/jquery-1.10.2.min.js></script><script src=/js/bootstrap.min.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-559846a374d7ecaa" async></script>